#include "EXPLOIT_DRAW_PLAY.h"
#include<random>
namespace GAME14 {
    void EXPLOIT::SET_IMAGE() {
        Image[0][1] = loadImage("..\\MAIN\\assets\\game14\\Commander.png");
        Image[0][0] = loadImage("..\\MAIN\\assets\\game14\\Commander_enemy.png");
        Image[1][1] = loadImage("..\\MAIN\\assets\\game14\\Lv.1.png");
        Image[1][0] = loadImage("..\\MAIN\\assets\\game14\\Lv.1_enemy.png");
        Image[2][1] = loadImage("..\\MAIN\\assets\\game14\\Lv.2.png");
        Image[2][0] = loadImage("..\\MAIN\\assets\\game14\\Lv.2_enemy.png");
        Image[3][1] = loadImage("..\\MAIN\\assets\\game14\\Lv.3.png");
        Image[3][0] = loadImage("..\\MAIN\\assets\\game14\\Lv.3_enemy.png");
        Image[4][1] = loadImage("..\\MAIN\\assets\\game14\\bommer.png");
        Image[4][0] = loadImage("..\\MAIN\\assets\\game14\\bommer_enemy.png");
        koma_Image[0] = loadImage("..\\MAIN\\assets\\game14\\asterisk.png");
        koma_Image[1] = loadImage("..\\MAIN\\assets\\game14\\pentagram.png");
        koma_Image[2] = loadImage("..\\MAIN\\assets\\game14\\strider.png");
        koma_Image[3] = loadImage("..\\MAIN\\assets\\game14\\strider.png");
        koma_Image[4] = loadImage("..\\MAIN\\assets\\game14\\pentagram.png");
        rule_num[0] = loadImage("..\\MAIN\\assets\\game14\\exploit_mikata.png");
        rule_num[1] = loadImage("..\\MAIN\\assets\\game14\\exploit.png");
        rule_num[2] = loadImage("..\\MAIN\\assets\\game14\\exploit_koma_red.png");
        rule_num[3] = loadImage("..\\MAIN\\assets\\game14\\exploit_koma_blue.png");
        rule_num[4] = loadImage("..\\MAIN\\assets\\game14\\exploit_level_red.png");
        rule_num[5] = loadImage("..\\MAIN\\assets\\game14\\exploit_level_blue.png");

    }
    void EXPLOIT::INIT() {
        Commander = false;
        Red_Boost_Flag = true;
        Blue_Boost_Flag = true;
        Available_Move = false;
        TILE_SIZE = 100;
        WIDTH = 750;
        HEIGHT = 200;
        Position_X = (Yoko / 2) - 425;
        Position_Y = Tate / 2;
        Position_X_2 = (Yoko / 2) - 425;
        Position_Y_2 = (Tate / 2) + 200;
        text_Potition_X = 650;
        text_Potition_Y = 200;
        text_Size = 200;
        for (int row = 0; row < 9; row++)
            for (int column = 0; column < 5; column++)
                matrix[row][column] = EMPTY;
        gameOver = false;
        now_Turn = PLAYER;
    }
    void EXPLOIT::PLAY_INIT() {
        // 全クリア
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 5; c++) {
                board[r][c].exist = false;
                board[r][c].movable = false;
            }
        }
        std::random_device random;
        std::mt19937 mt(random());
        std::uniform_int_distribution<int> dist(0, 4);
        std::uniform_int_distribution<int> koma(0, 2);
        int random_Num[5] = {};
        int random_Num_2[5] = {};
        for (int i = 0; i < 5; i++) {
            random_Num[i] = -1;
            random_Num_2[i] = -1;
        }
        for (int i = 0; i < 5; i++) {
            bool ok;
            do {
                ok = true;
                random_Num[i] = dist(mt);
                for (int j = 0; j < i; j++) {
                    if ((random_Num[i] == random_Num[j])) {
                        ok = false;
                        break;
                    }
                }
            } while (!ok);
        }
        int count1 = 0;
        int count2 = 0;
        for (int i = 0; i < 5; i++) {
            bool ok;
            do {
                ok = true;
                random_Num_2[i] = koma(mt);
                for (int j = 0; j < i; j++) {
                    if ((random_Num_2[i] == random_Num_2[j])) {
                        if (random_Num_2[i] == 1 && count1 == 0) {
                            count1++;
                            ok = true;
                            break;
                        }
                        else if (random_Num_2[i] == 2 && count2 == 0) {
                            count2++;
                            ok = true;
                            break;
                        }
                        else {
                            ok = false;
                            break;
                        }
                    }
                }
            } while (!ok);
        }
        for (int i = 0; i < 5; i++) {
            if (random_Num_2[i] == 1) {
                random_Num_2[i] = 3;
            }
            if (random_Num_2[i] == 2) {
                random_Num_2[i] = 4;
            }

        }
        // --- RED 側（上側） ---
        board[1][0] = { true, RED_UNIT, random_Num[0], random_Num_2[0], false,false }; // strider
        board[1][1] = { true, RED_UNIT, random_Num[1], random_Num_2[1], false ,false }; // pentagram
        board[1][2] = { true, RED_UNIT, random_Num[2], random_Num_2[2], false,false }; // asterisk
        board[1][3] = { true, RED_UNIT, random_Num[3], random_Num_2[3], false ,false };
        board[1][4] = { true, RED_UNIT, random_Num[4], random_Num_2[4], false ,false };
        for (int i = 0; i < 5; i++) {
            random_Num[i] = -1;
        }
        for (int i = 0; i < 5; i++) {
            bool ok;
            do {
                ok = true;
                random_Num[i] = dist(mt);
                for (int j = 0; j < i; j++) {
                    if (random_Num[i] == random_Num[j]) {
                        ok = false;
                        break;
                    }
                }
            } while (!ok);
        }
        count1 = 0;
        count2 = 0;
        for (int i = 0; i < 5; i++) {
            bool ok;
            do {
                ok = true;
                random_Num_2[i] = koma(mt);
                for (int j = 0; j < i; j++) {
                    if ((random_Num_2[i] == random_Num_2[j])) {
                        if (random_Num_2[i] == 1 && count1 == 0) {
                            count1++;
                            ok = true;
                            break;
                        }
                        else if (random_Num_2[i] == 2 && count2 == 0) {
                            count2++;
                            ok = true;
                            break;
                        }
                        else {
                            ok = false;
                            break;
                        }
                    }
                }
            } while (!ok);
        }

        // --- BLUE 側（下側） ---
        board[7][0] = { true, BLUE_UNIT, random_Num[0], random_Num_2[0], false,false };
        board[7][1] = { true, BLUE_UNIT, random_Num[1], random_Num_2[1], false,false };
        board[7][2] = { true, BLUE_UNIT, random_Num[2], random_Num_2[2], false ,false };
        board[7][3] = { true, BLUE_UNIT, random_Num[3], random_Num_2[3], false,false };
        board[7][4] = { true, BLUE_UNIT, random_Num[4], random_Num_2[4], false ,false };
    }
    void EXPLOIT::Clear() {
        for (int y = 0; y < 9; y++)
            for (int x = 0; x < 5; x++)
                matrix[y][x] = 0;
    }
    bool EXPLOIT::MOUSE_JUDGE(int WIDTH, int HEIGHT, float Pos_X, float Pos_Y) {
        if ((Pos_X) < mouseX && mouseX < (Pos_X)+WIDTH && (Pos_Y) < mouseY && mouseY < (Pos_Y)+HEIGHT) {
            return true;
        }
        else {
            return false;
        }
    }
    int EXPLOIT::TITLE_DRAW() {
        rectMode(CORNER);
        if (MOUSE_JUDGE(WIDTH, HEIGHT, Position_X - 50, Position_Y - (HEIGHT)) == true) {
            fill(255, 255, 50);
        }
        else {
            fill(255);
        }
        rect(Position_X - 50, Position_Y - (HEIGHT), WIDTH, HEIGHT);
        if (MOUSE_JUDGE(WIDTH, HEIGHT, Position_X - 25, ((Position_Y - (HEIGHT)) + HEIGHT) + 10) == true) {
            fill(255, 255, 50);
        }
        else {
            fill(255);
        }
        rect(Position_X_2 - 50, (Position_Y - (HEIGHT)+HEIGHT), WIDTH, HEIGHT);
        textSize(150);
        fill(255, 0, 0);
        text("EXPLOIT", (Yoko / 2) - 375, 300);
        fill(0);
        text("はじめる", Position_X, Position_Y - 25);
        text("もどる", Position_X_2, Position_Y_2 - 25);
        if (isTrigger(MOUSE_LBUTTON)) {
            if (MOUSE_JUDGE(WIDTH, HEIGHT, Position_X, Position_Y - HEIGHT) == true) {
                return 2;
            }
            else if (MOUSE_JUDGE(WIDTH, HEIGHT, Position_X_2, Position_Y_2 - HEIGHT) == true) {
                return 1;
            }
            else {
                return 0;
            }
        }
        else {
            return 0;
        }
    }

    void EXPLOIT::Koma_Moves(int komaIndex, int ky, int kx) {
        Clear();
        matrix[ky][kx] = 2;

        KOMA k = komaInfo[komaIndex];

        for (int i = 0; i < k.count; i++) {

            int y = ky;
            int x = kx;

            while (true) {
                y += k.move[i].Position_Y;
                x += k.move[i].Position_X;

                if (y < 0 || y >= 9 || x < 0 || x >= 5) break;

                matrix[y][x] = 1;

                if (!Commander) break;
            }
        }
    }
    /*
    void EXPLOIT::DrawBoard() {
        for (int y = 0; y < SIDE; y++) {
            for (int x = 0; x < SIDE; x++) {

                int px = x * TILE_SIZE;
                int py = y * TILE_SIZE;
                // fill(122, 122, 122);
               //  rect(px, py, px + TILE_SIZE, py + TILE_SIZE);

                if (matrix[y][x] == 2) {
                    fill(255, 122, 122);
                    rect(px, py, px + TILE_SIZE, py + TILE_SIZE);
                }
                else if (matrix[y][x] == 1) {
                    fill(0, 0, 255);
                    rect(px, py, px + TILE_SIZE, py + TILE_SIZE);
                    // matrix[y][x] = 2;
                }
                else {
                    fill(0);
                    rect(px, py, px + TILE_SIZE, py + TILE_SIZE);
                }
            }
        }
        fill(0);
    }
    */
    bool EXPLOIT::JUDGE_CAN_MOVE(int x, int y) {
        if (matrix[y][x] == 1) {
            return true;
        }
        else return false;
    }
    bool EXPLOIT::Mouse_To_Cell(int mx, int my, int& r, int& c) {
        r = my / TILE_SIZE;
        c = (mx - 300) / TILE_SIZE;
        if (r < 0 || r >= 9 || c < 0 || c >= 5)
            return false;

        return true;
    }
    void EXPLOIT::Setup_Cell_color() {
        // 一番上の行
        matrix[0][0] = RED_UNIT; // strider
        matrix[0][1] = RED_UNIT; // pentagram
        matrix[0][2] = RED_UNIT; // asterisk
        matrix[0][3] = RED_UNIT; // pentagram
        matrix[0][4] = RED_UNIT; // strider
        matrix[8][0] = BLUE_UNIT; // strider
        matrix[8][1] = BLUE_UNIT; // pentagram
        matrix[8][2] = BLUE_UNIT; // asterisk
        matrix[8][3] = BLUE_UNIT; // pentagram
        matrix[8][4] = BLUE_UNIT; // strider

        for (int i = 0; i < 5; i++) {
            matrix[1][i] = FRAME;
            matrix[7][i] = FRAME;
        }
    }

    void EXPLOIT::Draw_Board() {
        strokeWeight(2);
        if (now_Turn == PLAYER) {
            fill(0, 0, 255);
            rect(250, 0, 600, 950);
        }
        else if (now_Turn == ENEMY) {
            fill(255, 0, 0);
            rect(250, 0, 600, 950);
        }
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 5; c++) {
                int px = c * TILE_SIZE;
                int py = r * TILE_SIZE;

                if (matrix[r][c] == RED_UNIT) {
                    fill(255, 100, 100);
                }
                else if (matrix[r][c] == BLUE_UNIT) {
                    fill(100, 100, 255);
                }
                else if (matrix[r][c] == FRAME) {
                    fill(100);
                }
                else {
                    fill(200);
                }
                //rect(px, py, px + TILE_SIZE, py + TILE_SIZE);
                rect(px + 300, py, TILE_SIZE, TILE_SIZE);
                if (board[r][c].exist) {
                    if (board[r][c].disclosure) {
                        if (board[r][c].team == RED_UNIT) {
                            /*
                            if (board[r][c].level > 4) {
                                int img = Image[4][0];
                                image(img, px + 300, py);
                            }
                            else if (board[r][c].level < 0) {
                                int img = Image[0][0];
                                image(img, px + 300, py);
                            }
                            else {
                                int img = Image[board[r][c].level][0];
                                image(img, px + 300, py);
                            }
                            */
                            int img = Image[board[r][c].level][0];
                            image(img, px + 300, py);
                        }
                        else if (board[r][c].team == BLUE_UNIT) {
                            int img = Image[board[r][c].level][1];
                            image(img, px + 300, py);
                        }
                    }
                    else if ((now_Turn == ENEMY && board[r][c].team == RED_UNIT)) {
                        /*
                        if (board[r][c].level > 4) {
                            int img = Image[4][0];
                            image(img, px + 300, py);
                        }
                        else if (board[r][c].level < 0) {
                            int img = Image[0][0];
                            image(img, px + 300, py);
                        }
                        else {
                            int img = Image[board[r][c].level][0];
                            image(img, px + 300, py);
                        }
                        */
                        int img = Image[board[r][c].level][0];
                        image(img, px + 300, py);
                    }
                    else if ((now_Turn == PLAYER && board[r][c].team == BLUE_UNIT)) {
                        int img = Image[board[r][c].level][1];
                        image(img, px + 300, py);
                    }
                    /*
                    int img = Image[board[r][c].level][0];
                    image(img, px + 300, py);
                    int img_ = Image[board[r][c].level][1];
                    image(img_, px + 300, py);
                    */

                    // 駒タイプのマーク
                    image(koma_Image[board[r][c].komaType], px + 300, py);
                }

                // 移動可能マスの色
                if (board[r][c].movable) {
                    fill(0, 0, 255, 120);
                    rect(px + 300, py, TILE_SIZE, TILE_SIZE);
                }
            }
        }
        fill(0);
        noStroke();
    }
    void EXPLOIT::PlaceBlueUnit(int row, int col) {
        if (matrix[row][col] == EMPTY) {
            matrix[row][col] = BLUE_UNIT;
        }
    }
    /*
    0: RED 固定
    1 : ----- （区切り）
    2~6 : BLUE の配置ゾーン
    7 : ------
    8 : BLUE 固定（自陣）
    */
    bool EXPLOIT::IsBluePlacementZone(int row) {
        return (row >= 2 && row <= 6);
    }
    bool EXPLOIT::IsMyUnit(int row, int col) {
        if (!board[row][col].exist) return false;
        if (now_Turn == PLAYER && board[row][col].team == BLUE_UNIT)
            return true;
        if (now_Turn == ENEMY && board[row][col].team == RED_UNIT)
            return true;
        return false;
    }
    void EXPLOIT::SHOW_MOVABLE_AREA(int komaType, int row, int col) {
        /*
        Clear_Movable();

        KOMA k = komaInfo[komaType];

        for (int i = 0; i < k.count; i++) {
            int y = row;
            int x = col;
            int num = 0;

            while (num<2) {
                y += k.move[i].Position_Y;
                x += k.move[i].Position_X;

                if (y < 0 || y >= 9 || x < 0 || x >= 5) break;

                // 既にユニットがあるマスはそこまで（占有ブロック）
                if (board[y][x].exist && ((board[y][x].team - 1) == now_Turn)) break;

                board[y][x].movable = true;

                if (board[y][x].level == commander && now_Turn == PLAYER&& Blue_Boost_Flag == true) {
                    num++;
                    /*
                    if (Blue_Boost_Flag == true) {
                        num ++ ;
                    }
                    else {
                       // return;
                    }
                    */
        
        /*
                }
                else if (board[y][x].level == commander && now_Turn == ENEMY&& Red_Boost_Flag == true) {
                    num++;
                    /*
                    if (Red_Boost_Flag == true) {
                        num++;
                    }
                    else {
                      //  return;
                    }
                    */
        /*
                }
                else {
                    num = 0;
                    return;
                }
            }
        }
        */
        Clear_Movable();

        KOMA k = komaInfo[komaType];
        board[row][col].level == commander;
        int maxStep = 1;

        // ★ Commander + Boost 判定
        if (board[row][col].level == commander) {
            if (now_Turn == PLAYER && Blue_Boost_Flag) maxStep = 2;
            if (now_Turn == ENEMY && Red_Boost_Flag)  maxStep = 2;
        }

        for (int i = 0; i < k.count; i++) {
            int y = row;
            int x = col;

            for (int step = 0; step < maxStep; step++) {
                y += k.move[i].Position_Y;
                x += k.move[i].Position_X;

                if (y < 0 || y >= 9 || x < 0 || x >= 5) break;

                // 自分の駒でブロック
                if (board[y][x].exist &&
                    ((board[y][x].team - 1) == now_Turn)) {
                    break;
                }

                board[y][x].movable = true;

                // 敵駒がいたらそこで止まる
                if (board[y][x].exist) break;
            }
        }
    }
    void EXPLOIT::Clear_Movable() {
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 5; c++) {
                board[r][c].movable = false;
            }
        }
    }
    void EXPLOIT::KOMA_MOVE(int toRow, int toCol) {
        // 移動可能フラグが立っていなければ無視
        if (!board[toRow][toCol].movable) return;
        if (!hasSelected) return;

        CELL& from = board[selectedRow][selectedCol];
        CELL& to = board[toRow][toCol];

        // sanity check: from が存在していること
        if (!from.exist) {
            Select_Cancel();
            return;
        }
        //to=移動先.
        if (from.team == RED_UNIT) {
            //Debug_Num = from.level;
            if (to.exist && to.team != from.team) {
                if ((from.level) == Bommer || to.level == Bommer) {
                    to.exist = false;
                    from.exist = false;
                }
                else if (from.level >= to.level) {
                    // 必要ならここで「撃破演出 / スコア処理」を入れる
                   // to.exist = false;
                    from.disclosure = true;
                    to.disclosure = true;
                    to = from;
                    from.exist = false;
                }
                else {
                    from.disclosure = true;
                    to.disclosure = true;
                    from.exist = false;
                }
            }
            else {
                to = from;
                from.exist = false;
            }
            if (abs(toRow - selectedRow) > 1 || abs(toCol - selectedCol) > 1) {
                to.disclosure = true;
                Red_Boost_Flag = false;
            }
        }
        else {
           // Debug_Num = from.level;
            if (to.exist && to.team != from.team) {
                if (from.level == Bommer || (to.level) == Bommer) {
                    to.exist = false;
                    from.exist = false;
                }
                else if (from.level >= (to.level)) {
                    //to.exist = false;
                    from.disclosure = true;
                    to.disclosure = true;
                    to = from;
                    from.exist = false;
                }
                else {
                    from.disclosure = true;
                    to.disclosure = true;
                    from.exist = false;
                }
            }
            else {
                // 移動処理：to に from をコピーして from を空にする
                to = from;
                from.exist = false;
            }
            if (abs(toRow - selectedRow) > 1 || abs(toCol - selectedCol) > 1) {
                to.disclosure = true;
                Blue_Boost_Flag = false;
            }
        }

        // 移動後の状態リセット
        Clear_Movable();
        Select_Cancel(); // 選択解除も兼ねる
        // ★ ここでゲーム終了判定
        if (Check_GameOver()) return;
        // ターン交代
        now_Turn = (now_Turn == PLAYER) ? NEXT_E : NEXT_P;
    }
    void EXPLOIT::SELECT_KOMA(int y, int x) {
        Select_Cancel();
        if (board[y][x].exist) {

            hasSelected = true;
            selectedRow = y;
            selectedCol = x;
            selectedKomaType = board[y][x].komaType;

            SHOW_MOVABLE_AREA(selectedKomaType, y, x);
        }
    }
    //駒の位置や配置はランダム
    void EXPLOIT::Click_Cell(int r, int c) {
        if (hasSelected) {

            // 移動可能マスなら移動
            if (board[r][c].movable) {
                KOMA_MOVE(r, c);
                return;
            }
            // 別の自分の駒なら切り替え
            if (IsMyUnit(r, c) && board[r][c].exist) {
                SELECT_KOMA(r, c);
                return;
            }

            // それ以外押した → 解除
            Select_Cancel();
            return;
        }

        // 選択してないとき
        if (IsMyUnit(r, c) && board[r][c].exist) {
            SELECT_KOMA(r, c);
        }
    }
    void EXPLOIT::Select_Cancel() {
        hasSelected = false;
        selectedRow = -1;
        selectedCol = -1;
        selectedKomaType = -1;
        Clear_Movable();
    }
    bool EXPLOIT::HasCommander(int team) {
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 5; c++) {
                if (!board[r][c].exist) continue;
                if (board[r][c].team == BLUE_UNIT) {
                    if (board[r][c].team == team && board[r][c].level == commander) {
                        if (r < 2) {
                            //  if (board[r][c].team == BLUE_UNIT && board[r][c].level == commander) {
                            gameOver = true;
                            winner = BLUE_UNIT;
                            // }
                        }
                        return true;
                    }
                }
                else  if (board[r][c].team == RED_UNIT) {
                    if (board[r][c].team == team && (board[r][c].level) == commander) {
                        if (r > 6) {
                            //if (board[r][c].team == RED_UNIT && board[r][c].level == commander) {
                                gameOver = true;
                                winner = RED_UNIT;
                           // }
                        }
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    bool EXPLOIT::Check_GameOver() {
        bool redAlive = HasCommander(RED_UNIT);
        bool blueAlive = HasCommander(BLUE_UNIT);

        if (!redAlive || !blueAlive) {
            // 勝者判定

            if (!redAlive) {
                winner = BLUE_UNIT;
            }
            else {
                winner = RED_UNIT;
            }

            gameOver = true;
            return true;
        }
        return false;
    }
    void EXPLOIT::DRAW_Game_Finish() {
        if (gameOver) {
            textSize(300);

            if (winner == RED_UNIT) {
                fill(255, 0, 0);
                text("RED WIN!", 400, 700);
            }
            else if (winner == BLUE_UNIT) {
                fill(0, 0, 255);
                text("BLUE WIN!", 250, 700);
            }
            else
                text("DRAW", 300, 450);
            textSize(100);
            text("Next Game", 1015, 800);
            text("Press Space", 965, 900);
        }
    }
    bool EXPLOIT::Sent_gameOver() {
        return gameOver;
    }
    bool EXPLOIT::Back_TITLE() {
        textSize(100);
        fill(255);
        if (now_Turn == PLAYER) {
            fill(0, 0, 255);
            text("P.", 920, Tate);
            text(rule_page + 1, 1020, Tate);
            text("<A：D>", 1100, Tate);
        }
        else if (now_Turn == ENEMY) {
            fill(255, 0, 0);
            text("P.", 920, Tate);
            text(rule_page + 1, 1020, Tate);
            text("<A：D>", 1100, Tate);
        }
        text("TITLE:T", Yoko - 350, Tate);
        if (isTrigger(KEY_T)) {
            return true;
        }
        return false;
    }
    bool EXPLOIT::CHANGE_Turn() {
        if (!gameOver) {
            if (now_Turn == NEXT_E || now_Turn == NEXT_P) {
                rule_page = 0;
                if (now_Turn == NEXT_P) {
                    fill(0, 0, 255);
                    textSize(100);
                    text("次は青チームの番です", 200, 300);
                    textSize(50);
                    text("変わったら画面をクリックしてください", 200, 400);
                }
                else if (now_Turn == NEXT_E) {
                    fill(255, 0, 0);
                    textSize(100);
                    text("次は赤チームの番です", 200, 300);
                    textSize(50);
                    text("変わったら画面をクリックしてください", 200, 400);
                }
                if (isTrigger(MOUSE_LBUTTON)) {
                    now_Turn = (now_Turn == NEXT_P) ? PLAYER : ENEMY;
                }
                return true;
            }
        }
      return true ;
    }
    void EXPLOIT::RULE_IMAGE() {
        if (gameOver)return;
        if (isTrigger(KEY_A)) {
            rule_page--;
        }
        else if (isTrigger(KEY_D)) {
            rule_page++;
        }
        if (rule_page < 0) {
            rule_page = 2;
        }
        if (rule_page > 2) {
            rule_page = 0;
        }
        if (now_Turn == PLAYER) {
            if (rule_page == 0) {
                image(rule_num[0], 920, 0);
            }
            else if (rule_page == 1) {
                image(rule_num[3], 920, 0);
            }
            else if (rule_page == 2) {
                image(rule_num[5], 920, 0);
            }
        }
        else if (now_Turn == ENEMY) {
            if (rule_page == 0) {
                image(rule_num[1], 920, 0);
            }
            else if (rule_page == 1) {
                image(rule_num[2], 920, 0);
            }
            else if (rule_page == 2) {
                image(rule_num[4], 920, 0);
            }
        }
    }
    void EXPLOIT::DEBUG_DRAW() {
        if (Debug) {
            fill(0, 255, 0);
            text(Debug_Num, 1000, 200);
            text(now_Turn, 1000, 300);
            text(Blue_Boost_Flag, 1000, 400);
            text(Red_Boost_Flag, 1000, 500);

         //   rect(920, 80,900 ,900);
        }
    }
}